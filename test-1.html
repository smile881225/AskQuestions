<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
        }
    </style>
</head>

<body>

    <script type="x-shader/x-vertex" id="vertexshader">

        varying vec2 vUv;

        void main() {

            vUv = uv;

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

        }

    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

        uniform sampler2D baseTexture;
        uniform sampler2D bloomTexture;

        varying vec2 vUv;

        void main() {

            gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

        }

    </script>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
	</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from './jsm/controls/OrbitControls.js';
        import Stats from './jsm/libs/stats.module.js';
        import { GUI } from './jsm/libs/lil-gui.module.min.js';
        import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from './jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from './jsm/postprocessing/UnrealBloomPass.js';

        //匯入模型的import
        import { FBXLoader } from './Loader/FBXLoader/FBXLoader.js';
        import { OBJLoader } from './Loader/OBJLoader.js';
        import { MTLLoader } from './Loader/MTLLoader.js';
        import { GLTFLoader } from "./Loader/GLTFLoader.js";
        import { ShaderPass } from './jsm/postprocessing/ShaderPass.js';

        const ENTIRE_SCENE = 0, BLOOM_SCENE = 1;

        //設置發光的圖層為1
        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_SCENE);

        //設定GUI初始數值
        let params = {
            exposure: 1,
            bloomThreshold: 0.41,
            bloomStrength: 0.66,//強度
            bloomRadius: 0.01,
            scene: 'Scene with Glow'
        };

        //基本底色
        const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
        const materials = {};

        /*--------renderer--------*/
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        // renderer.shadowMap.enabled = true;//把Renderer的陰影選項打開
        // renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        //加入場景
        const scene = new THREE.Scene();

        /*--------相機--------*/
        var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 150, 200);//初始的Camera位置
        camera.lookAt(0, 0, 0);

        /*--------背景顏色--------*/
        // scene.background = new THREE.Color(0xffffff);

        /*--------移動視角--------*/
        let controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.enablePan = false;
        controls.maxPolarAngle = Math.PI / 2;
        controls.enableDamping = true;
        // controls.minDistance = 2000;
        // controls.maxDistance = 15000;

        /*--------載入燈光-1--------*/
        scene.add(new THREE.AmbientLight(0xffffff, 1));

        //Render
        const renderScene = new RenderPass(scene, camera);

        //設置bloom後處理通道
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = params.bloomThreshold;
        bloomPass.strength = params.bloomStrength;
        bloomPass.radius = params.bloomRadius;

        //把原本的renderer加到後處理通道
        const bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);
        bloomComposer.addPass(bloomPass);

        //最後合併的renderer通道
        const finalPass = new ShaderPass(
            new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: { value: null },
                    bloomTexture: { value: bloomComposer.renderTarget2.texture }
                },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                defines: {}
            }), 'baseTexture'
        );
        finalPass.needsSwap = true;

        const finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderScene);
        finalComposer.addPass(finalPass);

        // /*--------Stats--------*/
        // const stats = Stats();
        // stats.showPanel(0);
        // // 0：FPS，最近1秒的幀率，值越大表示性能越好；
        // // 1：MS，每一幀需要多少毫秒，值越小表示性能越好；
        // // 2：MB，所分配的内存，開Google的時候要加參數
        // document.body.appendChild(stats.dom);

        //燈光
        const light1 = new THREE.PointLight(0xddffdd, 1);
        light1.position.z = 0;
        light1.position.y = 300;
        light1.position.x = 200;
        scene.add(light1);

        // //GUI控制面板
        // const gui = new GUI();

        // gui.add(params, 'scene', ['Scene with Glow', 'Scene only']).onChange(function (value) {

        //     switch (value) {

        //         case 'Scene with Glow':
        //             bloomComposer.renderToScreen = false;
        //             break;
        //         case 'Scene only':
        //             // nothing to do
        //             break;

        //     }


        // });

        // const folder = gui.addFolder('Bloom Parameters');

        // folder.add(params, 'exposure', 0.1, 2).onChange(function (value) {

        //     renderer.toneMappingExposure = Math.pow(value, 4.0);

        // });

        // folder.add(params, 'bloomThreshold', 0.0, 1.0).onChange(function (value) {

        //     bloomPass.threshold = Number(value);

        // });

        // folder.add(params, 'bloomStrength', 0.0, 10.0).onChange(function (value) {

        //     bloomPass.strength = Number(value);

        // });

        // folder.add(params, 'bloomRadius', 0.0, 1.0).step(0.01).onChange(function (value) {

        //     bloomPass.radius = Number(value);

        // });

        //FBX模型設定
        let FBX_name = ['group0'];
        let FBX_loader = ['loader0'];
        let FBX_url = [
            './models/2022-5-16/2022-05-16-貯木池.fbx',
        ];

        //FBX匯入模組化
        function FBXimport(object_name, object_loader, object_url) {
            object_loader = new FBXLoader();
            object_loader.load(object_url, function (object) {
                object_loader = new THREE.AnimationMixer(object);
                object.traverse(function (child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                object.position.set(0, 0, 0);
                object.name = object_name;
                object.children[0].name = object_name;
                object.scale.set(0.01, 0.01, 0.01);
                scene.add(object);
                object.layers.enable(BLOOM_SCENE);
            });
            const group = scene.getObjectByName(object_name);
        }

        for (let i = 0; i < FBX_name.length; i++) {
            FBXimport(FBX_name[i], FBX_loader[i], FBX_url[i]);
            console.log(`模型${i}的name：${FBX_name[i]}`);
            console.log(`模型${i}的url：${FBX_name[i]}`);
        }

        // /*--------OBJ模型-地板--------*/
        // var objLoader = new OBJLoader();
        // var mtlLoader = new MTLLoader();
        // var url = "./models/2022-5-16/2022-04-13-FINALTEST.mtl";
        // var OBJMoudels;
        // mtlLoader.load(url, function (materials) {
        //     materials.preload();
        //     objLoader.setMaterials(materials);
        //     OBJMoudels = objLoader.load('./models/2022-5-16/2022-04-13-FINALTEST.obj', function (object) {
        //         object.traverse(function (node) {
        //             if (node instanceof THREE.Mesh) {
        //                 node.castShadow = true; //default is false
        //                 // node.receiveShadow = false; //default
        //                 node.receiveShadow = true; //default
        //             }
        //         })
        //         object.position.set(0,0,0);//初始的Camera位置
        //         object.name = "plane";
        //         object.children[0].name = "plane";
        // object.scale.set(0.01,0.01,0.01);
        //         // scene.add(object);
        //     });
        // });

        /*--------滑鼠互動--------*/
        const raycaster = new THREE.Raycaster();//設定2D的射線(不懂請看觀念->滑鼠互動->58 Three.js...)

        const mouse = new THREE.Vector2();
        setTimeout(window.addEventListener('mousemove', onMouseMove), 1000);


        function onMouseMove(event) {

            //通過滑鼠點選的位置計算出raycaster所需要的點的位置，以螢幕中心為原點，值的範圍為-1到1.

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // 通過滑鼠點的位置和當前相機的矩陣計算出raycaster
            raycaster.setFromCamera(mouse, camera);
            let intersects;
            for (let i = 0; i < scene.children[2].children.length; i++) {
                // ENTIRE_SCENE=0
                // BLOOM_SCENE=1
                scene.children[2].children[i].layers.set(ENTIRE_SCENE);
            }
            // 獲取raycaster直線和所有模型相交的陣列集合
            if (raycaster.intersectObjects(scene.children)[0]) {
                intersects = raycaster.intersectObjects(scene.children);

                const intersects_object_name = intersects[0].object.name;
                // switch (intersects_object_name) {
                //     //後處理的發亮輸出
                //     case 'plane':
                //         renderer.render(scene, camera);

                //     case 'house1':
                //         intersects[0].object.layers.enableAll(BLOOM_SCENE);

                //     case 'house2':
                //         intersects[0].object.layers.enableAll(BLOOM_SCENE);

                //     case 'house3':
                //         intersects[0].object.layers.enableAll(BLOOM_SCENE);

                //     case 'group0':
                //         intersects[0].object.layers.enableAll(BLOOM_SCENE);
                // }
                if (intersects_object_name != "plane" && intersects_object_name != "Object010") {
                    intersects[0].object.layers.enableAll(BLOOM_SCENE);
                }
                // console.log(scene.children);
                // console.log(intersects[0].object.parent.name);
                // console.log(intersects[0].object);
            }
        }

        //當遊覽器的視窗大小改變
        window.onresize = function () {

            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);

            bloomComposer.setSize(width, height);
            finalComposer.setSize(width, height);

            render();

        };

        function disposeMaterial(obj) {

            if (obj.material) {

                //刪除material 不刪除Textures 
                obj.material.dispose();

            }

        }


        //最後輸出
        function render() {

            //選擇輸出方式
            switch (params.scene) {

                //後處理的發亮輸出
                case 'Scene only':
                    renderer.render(scene, camera);
                    break;

                //預設的一般輸出
                case 'Scene with Glow':

                //預設的一般輸出
                default:
                    // render scene with bloom
                    renderBloom(true);

                    // render the entire scene, then render bloom scene on top
                    finalComposer.render();
                    break;

            }

        }
        function renderBloom(mask) {

            if (mask === true) {
                renderer.setClearColor(0x000000); // all must be black, including background
                scene.traverse(darkenNonBloomed);
                bloomComposer.render();
                renderer.setClearColor(0xffffff); // set the color you want
                scene.traverse(restoreMaterial);
            } else {
                camera.layers.set(BLOOM_SCENE);
                bloomComposer.render();
                camera.layers.set(ENTIRE_SCENE);
            }
        }

        function darkenNonBloomed(obj) {
            if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
                materials[obj.uuid] = obj.material;
                obj.material = darkMaterial;
            }
        }

        function restoreMaterial(obj) {

            if (materials[obj.uuid]) {

                obj.material = materials[obj.uuid];
                delete materials[obj.uuid];

            }

        }

        function animate() {
            controls.update();
            // stats.update();
            render();
            requestAnimationFrame(animate);
        };
        animate();

    </script>
</body>

</html>