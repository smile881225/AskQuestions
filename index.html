<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            position: relative;
            overflow: hidden;
            height: 100vh;
            width: 100%;
        }
    </style>
</head>

<body>

    <script src="./build/three.js"></script>

    <script type="module">
        import * as THREE from './build/three.module.js';
        import { OrbitControls } from './jsm/controls/OrbitControls.js';
        import Stats from './jsm/libs/stats.module.js';
        import { GUI } from './jsm/libs/lil-gui.module.min.js';
        import { OBJLoader } from './Loader/OBJLoader.js';
        import { MTLLoader } from './Loader/MTLLoader.js';
        import { FBXLoader } from './Loader/FBXLoader/FBXLoader.js';


        const scene = new THREE.Scene();

        /*--------camera--------*/
        var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 40, 20);//初始的Camera位置
        camera.lookAt(0, 0, 0);

        /*--------renderer--------*/
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true;//把Renderer的陰影選項打開
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ReinhardToneMapping;

        /*--------background--------*/
        scene.background = new THREE.Color(0xffffff);

        /*--------OrbitControls--------*/
        let controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.maxPolarAngle = Math.PI / 2;
        controls.enableDamping = true;
        // controls.minDistance = 100;
        // controls.maxDistance = 1000;

        //FBX
        let FBX_name = ['group0',];
        let FBX_loader = ['loader0',];
        let FBX_url = [
            './models/2022-5-16/2022-05-16-model.fbx',
        ];

        //FBX
        function FBXimport(object_name, object_loader, object_url) {
            object_loader = new FBXLoader();
            object_loader.load(object_url, function (object) {
                object_loader = new THREE.AnimationMixer(object);
                object.traverse(function (child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                object.position.set(0, 0, 0);
                object.name = object_name;
                object.children[0].name = object_name;
                object.scale.set(0.01, 0.01, 0.01);
                scene.add(object);
            });
            const group = scene.getObjectByName(object_name);
        }
        
        for (let i = 0; i < FBX_name.length; i++) {
            FBXimport(FBX_name[i], FBX_loader[i], FBX_url[i]);
        }

        const light = new THREE.HemisphereLight(0xffeeb1, 0x080820, 4);
        scene.add(light);

        const directionalLight = new THREE.DirectionalLight(0xffa95c, 5);
        directionalLight.position.set(-50, 50, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.bias = -0.0001;
        directionalLight.shadow.mapSize.width = 1024 * 4; // default
        directionalLight.shadow.mapSize.height = 1024 * 4; // default
        scene.add(directionalLight);

        const helper = new THREE.DirectionalLightHelper(directionalLight, 5);
        scene.add(helper);

        //當遊覽器的視窗大小改變
        window.onresize = function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };

        function animate() {
            controls.update();
            // stats.update();
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };
        animate();

    </script>
</body>

</html>